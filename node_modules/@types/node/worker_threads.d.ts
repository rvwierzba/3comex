/**
 * The `node:worker_threads` module enables the use of threads that execute
 * JavaScript in parallel. To access it:
 *
 * ```js
 * import worker from 'node:worker_threads';
 * ```
 *
 * Workers (threads) are useful for performing CPU-intensive JavaScript operations.
 * They do not help much with I/O-intensive work. The Node.js built-in
 * asynchronous I/O operations are more efficient than Workers can be.
 *
 * Unlike `child_process` or `cluster`, `worker_threads` can share memory. They do
 * so by transferring `ArrayBuffer` instances or sharing `SharedArrayBuffer` instances.
 *
 * ```js
 * import {
 *   Worker, isMainThread, parentPort, workerData,
 * } from 'node:worker_threads';
 * import { parse } from 'some-js-parsing-library';
 *
 * if (isMainThread) {
 *   module.exports = function parseJSAsync(script) {
 *     return new Promise((resolve, reject) => {
 *       const worker = new Worker(__filename, {
 *         workerData: script,
 *       });
 *       worker.on('message', resolve);
 *       worker.on('error', reject);
 *       worker.on('exit', (code) => {
 *         if (code !== 0)
 *           reject(new Error(`Worker stopped with exit code ${code}`));
 *       });
 *     });
 *   };
 * } else {
 *   const script = workerData;
 *   parentPort.postMessage(parse(script));
 * }
 * ```
 *
 * The above example spawns a Worker thread for each `parseJSAsync()` call. In
 * practice, use a pool of Workers for these kinds of tasks. Otherwise, the
 * overhead of creating Workers would likely exceed their benefit.
 *
 * When implementing a worker pool, use the `AsyncResource` API to inform
 * diagnostic tools (e.g. to provide asynchronous stack traces) about the
 * correlation between tasks and their outcomes. See `"Using AsyncResource for a Worker thread pool"` in the `async_hooks` documentation for an example implementation.
 *
 * Worker threads inherit non-process-specific options by default. Refer to `Worker constructor options` to know how to customize worker thread options,
 * specifically `argv` and `execArgv` options.
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/worker_threads.js)
 */
declare module "worker_threads" {
    import { Blob } from "node:buffer";
    import { Context } from "node:vm";
    import { EventEmitter } from "node:events";
    import { EventLoopUtilityFunction } from "node:perf_hooks";
    import { FileHandle } from "node:fs/promises";
    import { Readable, Writable } from "node:stream";
    import { URL } from "node:url";
    import { X509Certificate } from "node:crypto";
    const isMainThread: boolean;
    const parentPort: null | MessagePort;
    const resourceLimits: ResourceLimits;
    const SHARE_ENV: unique symbol;
    const threadId: number;
    const workerData: any;
    /**
     * Instances of the `worker.MessageChannel` class represent an asynchronous,
     * two-way communications channel.
     * The `MessageChannel` has no methods of its own. `new MessageChannel()` yields an object with `port1` and `port2` properties, which refer to linked `MessagePort` instances.
     *
     * ```js
     * import { MessageChannel } from 'node:worker_threads';
     *
     * const { port1, port2 } = new MessageChannel();
     * port1.on('message', (message) => console.log('received', message));
     * port2.postMessage({ foo: 'bar' });
     * // Prints: received { foo: 'bar' } from the `port1.on('message')` listener
     * ```
     * @since v10.5.0
     */
    class MessageChannel {
        readonly port1: MessagePort;
        readonly port2: MessagePort;
    }
    interface WorkerPerformance {
        eventLoopUtilization: EventLoopUtilityFunction;
    }
    type TransferListItem = ArrayBuffer | MessagePort | FileHandle | X509Certificate | Blob;
    /**
     * Instances of the `worker.MessagePort` class represent one end of an
     * asynchronous, two-way communications channel. It can be used to transfer
     * structured data, memory regions and other `MessagePort`s between different `Worker`s.
     *
     * This implementation matches [browser `MessagePort`](https://developer.mozilla.org/en-US/docs/Web/API/MessagePort) s.
     * @since v10.5.0
     */
    class MessagePort extends EventEmitter {
        /**
         * Disables further sending of messages on either side of the connection.
         * This method can be called when no further communication will happen over this `MessagePort`.
         *
         * The `'close' event` is emitted on both `MessagePort` instances that
         * are part of the channel.
         * @since v10.5.0
         */
        close(): void;
        /**
         * Sends a JavaScript value to the receiving side of this channel. `value` is transferred in a way which is compatible with
         * the [HTML structured clone algorithm](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm).
         *
         * In particular, the significant differences to `JSON` are:
         *
         * * `value` may contain circular references.
         * * `value` may contain instances of builtin JS types such as `RegExp`s, `BigInt`s, `Map`s, `Set`s, etc.
         * * `value` may contain typed arrays, both using `ArrayBuffer`s
         * and `SharedArrayBuffer`s.
         * * `value` may contain [`WebAssembly.Module`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WebAssembly/Module) instances.
         * * `value` may not contain native (C++-backed) objects other than:
         *
         * ```js
         * import { MessageChannel } from 'node:worker_threads';
         * const { port1, port2 } = new MessageChannel();
         *
         * port1.on('message', (message) => console.log(message));
         *
         * const circularData = {};
         * circularData.foo = circularData;
         * // Prints: { foo: [Circular] }
         * port2.postMessage(circularData);
         * ```
         *
         * `transferList` may be a list of [`ArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer), `MessagePort`, and `FileHandle` objects.
         * After transferring, they are not usable on the sending side of the channel
         * anymore (even if they are not contained in `value`). Unlike with `child processes`, transferring handles such as network sockets is currently
         * not supported.
         *
         * If `value` contains [`SharedArrayBuffer`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer) instances, those are accessible
         * from either thread. They cannot be listed in `transferList`.
         *
         * `value` may still contain `ArrayBuffer` instances that are not in `transferList`; in that case, the underlying memory is copied rather than moved.
         *
         * ```js
         * import { MessageChannel } from 'node:worker_threads';
         * const { port1, port2 } = new MessageChannel();
         *
         * port1.on('message', (message) => console.log(message));
         *
         * const uint8Array = new Uint8Array([ 1, 2, 3, 4 ]);
         * // This posts a copy of `uint8Array`:
         * port2.postMessage(uint8Array);
         * // This does not copy data, but renders `uint8Array` unusable:
         * port2.postMessage(uint8Array, [ uint8Array.buffer ]);
         *
         * // The memory for the `sharedUint8Array` is accessible from both the
         * // original and the copy received by `.on('message')`:
         * const sharedUint8Array = new Uint8Array(new SharedArrayBuffer(4));
         * port2.postMessage(sharedUint8Array);
         *
         * // This transfers a freshly created message port to the receiver.
         * // This can be used, for example, to create communication channels between
         * // multiple `Worker` threads that are children of the same parent thread.
         * const otherChannel = new MessageChannel();
         * port2.postMessage({ port: otherChannel.port1 }, [ otherChannel.port1 ]);
         * ```
         *
         * The message object is cloned immediately, and can be modified after
         * posting without having side 